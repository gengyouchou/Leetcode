### 28. Implement strStr()

此題用KMP解，讓腦袋更加的清晰，首先建立一個最長公共前後輟dp，比方說字串S1[aaaaa]，那麼最長公共前後輟dp=[0,1,2,3,4]，KMP的精神便是比較過的字符
無需再比較一次，我們注意dp[4]=4代表截至目前為止的前4個位置都已經否配了，所以可以放心的將來源字串的index+1並且持續從目標字符串index（j）=5開始比較。

具體怎麼實作呢？用一個S1的副本S2相當於自己與自己比較，但S2從位置1開始，S1從位置0開始比較，如此才能在基於當數組長度為1時之最長共前後輟為０，

S1[aaaaa]

S2[aaaaa]

S2從位置1開始，S1從位置0開始比較

　　　　　　i

S1:ａａａａａ

　　　　　　j
  
S2:ｘａａａａａ
 
dp:０１２３４

由上述可看出如果S1[i]==S2[j]那麼dp[i]=j+1，否則：

　　　　　i

S1:ａａｂａａ

　　　j
  
S2:ｘａａｂａａ

dp:０１０１２

將j=dp[j-1]做跳轉不斷比較直到j<=0。

最後將目標字串的最長公共前後輟帶入原始的比較模式中，若當前否配的字符相等則目標字串index(j)+1直到等於本身長度時，代表找到解，起始位置存在於來源字串當前index(i)減去目標字串長度，注意整個過程來源字串index(i)是不斷遞增的。

如果當前字符不否配則目標字串index(j)不斷跳轉(index(j)=dp[j-1])直到來源字串遍歷完閉，整體時間複雜度為線性，最高為O（m+n），m、n分別為兩個字串的長度。

